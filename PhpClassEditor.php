<?php

namespace DocDigital\Lib\SourceEditor;

use DocDigital\Lib\SourceEditor\ClassStructure\AttributeElement;
use DocDigital\Lib\SourceEditor\ClassStructure\ClassElement;
use DocDigital\Lib\SourceEditor\ClassStructure\ConstantElement;
use DocDigital\Lib\SourceEditor\ClassStructure\DocBlock;
use DocDigital\Lib\SourceEditor\ClassStructure\Element;
use DocDigital\Lib\SourceEditor\ClassStructure\MethodElement;
use DocDigital\Lib\SourceEditor\ClassStructure\TraitElement;

/**
 * Attempts to handle modiffications in existing PHP Class, by adding annotations
 * to specific properties, adding properties and methods.
 *
 * This is useful for instance to add annotations to an entity Generated by
 * {@link \Doctrine\ORM\Tools\EntityGenerator}
 *
 * The Idea is to make is simple to get parts of the code as relevant elements and
 * manipulate them. In the next example I have 3 relevant elements, each having
 * sub-elements accessible from the main (parent??) one.
 *
 * <pre>
 * / **
 *  * Class Doc Block
 *  * /
 * class a
 * {
 *     /**
 *      * Attr Doc Block
 *      * /
 *     public $attr
 *
 *     /**
 *      * Fn Doc Block
 *      * /
 *     public function b()
 *     {
 *     }
 * }
 * <elemnet class>
 *     <docBlock/>
 *     <element attribute>
 *         <docBlock/>
 *     </element >
 *     <element method>
 *         <docBlock/>
 *     </element >
 * </elemnet>
 * </pre>
 *
 * Then you should be able to issue:
 *    $classEditor->getClass('a')->getMethod('b')->addAnnotation('@auth Juan Manuel Fernandez <juanmf@gmail.com>');
 *    $classEditor->getClass('a')->getAttribute('attr')->addAnnotation('@Assert\Choice(...)');
 *    $classEditor->getClass('a')->addAttribute($attr2);
 *
 * @author Juan Manuel Fernandez <juanmf@gmail.com>
 */
class PhpClassEditor
{
    /**
     * Parsed classes in input File
     *
     * @var ClassStructure\ClassElement[]
     */
    private $classes = array();

    /**
     *
     * @var TokenParser
     */
    private $tokenParser = null;

    /**
     * Some elements (e.g. docBlock, use and namespace) are found before its owner.
     * buffer them here.
     *
     * @var ElementBuilder[]
     */
    private $elementsBuffer = array();

    /**
     * Witness to know if Parser is goin outter or inner for a new context.
     *
     * @var string
     */
    private $previousContext = array();

    /**
     * When parsing, currently or last created method reference is held here.
     *
     * @var MethodElement
     */
    private $lastCreatedMethod;

    /**
     * Sets this editor's parser instance
     *
     * @param TokenParser $tokenParser The token Parser
     *
     */
    public function __construct(TokenParser $tokenParser)
    {
        $this->tokenParser = $tokenParser;
    }

    /**
     * Parses php file in given path
     *
     * @param string $classPath The File absolute path
     *
     * @return ClassElement[] The classes found in File. Represented by ClassElement
     * @throws \InvalidArgumentException if file does not exist.
     */
    public function parseFile($classPath)
    {
        // TODO: check classExists as per file name too
        if (! file_exists($classPath)) {
            throw new \InvalidArgumentException(
                sprintf('%s No such File.', $classPath)
            );
        }
        $source = file_get_contents($classPath);
        $this->tokenParser->setSource(
            $source,
            function(ElementBuilder $e) {$this->processElement($e);},
            function($newContext, $oldContext, ElementBuilder $e) {
                $this->processContextChange($newContext, $oldContext, $e);
            }
        );
        $this->tokenParser->parseCode();
        return $this->classes;
    }

    /**
     * This is wrapped in a closure passed to self::tokenParser, each time an
     * ElementBuilder is closed, its forwarded to this method for populating the classes
     * attributes, constants and method representations.
     *
     * Depending on the context the element is found, the treatment it receives.
     *
     * @param ElementBuilder $e
     */
    public function processElement(ElementBuilder $e)
    {
        $this->elementsBuffer[] = $e;
        switch($e->context) {
            case TokenParser::CONTEXT_PHP:
                // Class Context End '}' comes throughg this context, TokenParser::CONTEXT_PHP.
                break;
            case TokenParser::CONTEXT_CLASS:
                $this->addElementToClass($e);
                break;
            case TokenParser::CONTEXT_METHOD:
                // TODO: as I'm not looking inside Method only chance to be here is a
                // inner DocBlock or the method signature that gets cut appart or its complete body !
                $this->handleMethodElementBuilder($e);
                break;
        }
    }

    /**
     * Generates a new class on TokenParser::CONTEXT_PHP => TokenParser::CONTEXT_CLASS
     * context change.
     *
     * This callback is called when a context change occurs, either to a deeper (class => method)
     * or to an outer one (method => class).
     *
     * @param string         $newContext One of the TokenParser::CONTEXT_* constants.
     * @param string         $oldContext One of the TokenParser::CONTEXT_* constants.
     * @param ElementBuilder $e          An empty element builder (since no token gets
     * loaded in context change callback invocation). But with {@link ElementBuilder::startPointer}
     * set.
     *
     * @see TokenParser::CONTEXT_*
     */
    public function processContextChange($newContext, $oldContext, ElementBuilder $e)
    {
        $swap = $oldContext . $newContext;
        $php = TokenParser::CONTEXT_PHP;
        $class = TokenParser::CONTEXT_CLASS;
        $method = TokenParser::CONTEXT_METHOD;
        switch($swap) {
            case $php . $class:
                $this->loadNewClass($e);
                break;
            case $class . $method:
                // Nothing to do, I'll wait for the Method element to be processed
                break;
            case $method . $class:
                break;
            case $class . $php:
                break;
        }
    }

    /**
     * Finds Class in loaded file and returns its representation.
     *
     * @param type $name
     *
     * @return ClassElement The desired Class or null.
     */
    public function getClass($name)
    {
        if (! isset($this->classes[$name])) {
            return null;
        }
        return $this->classes[$name];
    }

    /**
     * Figures out the element Type and adds it to the right Collection.
     * Outer (use, docBlock) Collections and namespace should already be filled,
     * in {@link self::loadNewClass()}
     *
     * Use buffered ElementBuilders to add preceding gap and Doc elements to class
     * flat element array and Element's DocBlock Collection.
     *
     * @param ElementBuilder $e The Element to load.
     */
    public function addElementToClass(ElementBuilder $e)
    {
        $class = end($this->classes);
        /* @var $class ClassElement */
        switch($e->elementType) {
            case $this->tokenParser->figureOutElementType(TokenParser::CONTEXT_CLASS, TokenParser::CONTEXT_PHP):
                $this->setClassDef($class, $e);
                break;
            case $this->tokenParser->figureOutElementType(T_USE, TokenParser::CONTEXT_CLASS):
                $class->addTrait($this->createTrait($e));
                break;
            case $this->tokenParser->figureOutElementType(T_CONST, TokenParser::CONTEXT_CLASS):
                $class->addConst($this->createConstant($e));
                break;
            case $this->tokenParser->figureOutElementType(T_PRIVATE, TokenParser::CONTEXT_CLASS):
            case $this->tokenParser->figureOutElementType(T_PUBLIC, TokenParser::CONTEXT_CLASS):
            case $this->tokenParser->figureOutElementType(T_PROTECTED, TokenParser::CONTEXT_CLASS):
            case $this->tokenParser->figureOutElementType(T_VAR, TokenParser::CONTEXT_CLASS):
                $class->addAttribute($this->createAttribute($e));
                break;
            case ElementBuilder::TYPE_START_CONTEXT_END_TOKEN:
                // Class just opened, token should be '{'
                $class->addElement($e);
                $this->elementsBuffer = array();
                break;
            case ElementBuilder::TYPE_END_CONTEXT_TOKEN:
                // Class just closed, token should be '}'
                // Shouldnt find docBlocks here, but add the rest of gap tokens and clears buffer.
                $this->addElementDocBlock($class);
                break;
        }
    }

    /**
     * Sets current parsing class declaration and adds the ElemenBuilder to flat
     * elements array
     *
     * ElementBuilder containing "[abstract ]class XX [extends] [implements]"
     * elementsBuffer should contain only this ElementBuilder since
     * {@link sef::loadNewClass()} was just called wipping it.
     *
     * @param ClassElement   $class current parsing class
     * @param ElementBuilder $e     The ElementBuilder containing class declaration
     */
    private function setClassDef(ClassElement $class, ElementBuilder $e)
    {
        $class->setClassDef($e);
        $class->addElement($e);
        $this->elementsBuffer = array();
    }

    /**
     * Initializes new Class. Filling Class' outer elements collections with available
     * buffered elements.
     *
     * @param type $e
     */
    public function loadNewClass(ElementBuilder $e)
    {
        $name = $this->tokenParser->findElementName($e);
        $class = $this->classes[$name] = new ClassElement();
        $class->setName($name);
        $this->setClassHeader($class);
    }

    /**
     * As T_CLASS comes after header (namespace, use, doc, whatever..) finishes,
     * needed elements are in {@link self::elementsBuffer} or alternatively in given
     * $elements. Adds each element to its Collection, according to
     * {@link ElementBuilder::$elementType}.
     *
     * @param ClassElement     $class    The Class representation that is getting filled.
     * @param ElementBuilder[] $elements The Elements that compose the header.
     *
     * @return void.
     */
    public function setClassHeader(ClassElement $class, array $elements = array())
    {
        empty($elements) && $elements = $this->elementsBuffer;
        foreach ($elements as $element) {
            /* @var $element ElementBuilder */
            switch($element->elementType) {
                case $this->tokenParser->figureOutElementType(T_NAMESPACE, TokenParser::CONTEXT_PHP):
                    $class->setNameSpace($element);
                    break;
                case $this->tokenParser->figureOutElementType(T_USE, TokenParser::CONTEXT_PHP):
                    $class->addUse($element);
                    break;
                case $this->tokenParser->figureOutElementType(T_DOC_COMMENT, TokenParser::CONTEXT_PHP):
                    $class->addDocBlock(new DocBlock($element));
                    break;
            }
            $class->addElement($element);
        }
        $this->elementsBuffer = array();
    }

    /**
     * Creates an instance of AttributeElement with the given ElementBuilder, and
     * tries to assign it its DocBlock.
     *
     * Gap elements are loaded as generic elements. to preserve their order.
     *
     * @param ElementBuilder $e
     */
    public function createAttribute(ElementBuilder $e)
    {
        $attr = new AttributeElement(end($this->classes));
        $this->addElementDocBlock($attr);
        $attr->addBodyElement($e);
        $attr->setName(str_replace('$', '', $this->tokenParser->findElementName($e)));
        return $attr;
    }

    /**
     * Creates an instance of ConstantElement with the given ElementBuilder, and
     * tries to assign it its DocBlock.
     *
     * Gap elements are loaded as generic elements. to preserve their order.
     *
     * @param ElementBuilder $e
     */
    public function createTrait(ElementBuilder $e)
    {
        $tarit = new TraitElement(end($this->classes));
        $this->addElementDocBlock($tarit);
        $tarit->addBodyElement($e);
        $tarit->setName($this->tokenParser->findElementName($e));
        return $tarit;
    }

    /**
     * Creates an instance of ConstantElement with the given ElementBuilder, and
     * tries to assign it its DocBlock.
     *
     * Gap elements are loaded as generic elements. to preserve their order.
     *
     * @param ElementBuilder $e
     */
    public function createConstant(ElementBuilder $e)
    {
        $const = new ConstantElement();
        $this->addElementDocBlock($const);
        $const->addBodyElement($e);
        $const->setName($this->tokenParser->findElementName($e));
        return $const;
    }

    /**
     * adds buffered elementBuilders to the class flat elements array, and the ones
     * that are DocBlocks (T_DOC_COMMENT) are also added to $classElement::docBlock
     * Collection
     *
     * @param Element $structureElement The class element [Attr|Const].
     */
    protected function addElementDocBlock(Element $structureElement)
    {
        foreach ($this->elementsBuffer as $element) {
            switch ($element->elementType) {
                case $this->tokenParser->figureOutElementType(T_DOC_COMMENT, TokenParser::CONTEXT_CLASS):
                    $structureElement->addDocBlock(new DocBlock($element));
                    break;
            }
            // Last element should be the [Attr|Const|trait] body e.g. "public $var = null;"
            $structureElement->addElement($element);
        }
        $this->elementsBuffer = array();
    }

    /**
     * Handles Mothod creation and its addition to currently parsing class.
     *
     * Note that the closing token '}' is handled in context TokenParser::CONTEXT_CLASS,
     * as a context method closing token, it triggers context change before.
     *
     * @param ElementBuilder $e
     */
    public function handleMethodElementBuilder(ElementBuilder $e)
    {
        $class = end($this->classes);
        /* @var $class ClassElement */
        switch ($e->elementType) {
            case $this->tokenParser->figureOutElementType(TokenParser::CONTEXT_METHOD, TokenParser::CONTEXT_CLASS):
                // Method Signature
                $class->addMethod($this->createMethod($e));
                break;
            case ElementBuilder::TYPE_GAP:
                // Method code
                $this->lastCreatedMethod->addBodyElement($e);
                $this->elementsBuffer = array();
                break;
            case ElementBuilder::TYPE_END_CONTEXT_TOKEN:
                // Method closing '}'
            case ElementBuilder::TYPE_START_CONTEXT_END_TOKEN:
                // Method opening '{'
                $this->lastCreatedMethod->addElement($e);
                $this->elementsBuffer = array();
                break;
        }
    }

    /**
     * Takes an ElementBuilder of type "TokenParser::CONTEXT_CLASS~TokenParser::CONTEXT_METHOD"
     * and retusn a new MethodElement instance
     *
     * @param ElementBuilder $e
     *
     * @return MethodElement the newly created method representation.
     */
    public function createMethod(ElementBuilder $e)
    {
        $method = new MethodElement(end($this->classes));
        $method->setSignature($e);
        $method->setName($this->tokenParser->findElementName($e));
        $this->addElementDocBlock($method);
        $this->lastCreatedMethod = $method;
        return $method;
    }
}
